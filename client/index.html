<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>軽量地図表示（新アプローチ）</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
            user-select: none;
        }
        #mapContainer {
            position: fixed;
            inset: 0;
            cursor: grab;
            touch-action: none;
        }
        #mapContainer.dragging {
            cursor: grabbing;
        }
        #mapGrid {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        .tile {
            position: absolute;
        }
        .tile img {
            width: 100%;
            height: 100%;
            display: block;
        }
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            z-index: 1000;
            color: white;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="mapContainer">
        <div id="mapGrid"></div>
    </div>
    
    <div id="controls">
        <div id="info"></div>
    </div>

    <script src="wasm_exec.js"></script>
    <script>
        if (!WebAssembly.instantiateStreaming) {
            WebAssembly.instantiateStreaming = async (resp, importObject) => {
                const source = await resp.arrayBuffer();
                return WebAssembly.instantiate(source, importObject);
            };
        }

        const go = new Go();
        let wasmModule, instance;
        let mapInitialized = false;

        async function loadWasm() {
            try {
                const result = await WebAssembly.instantiateStreaming(
                    fetch("app.wasm"), go.importObject
                );
                wasmModule = result.module;
                instance = result.instance;
                go.run(instance);
                console.log("Go WebAssembly loaded and running.");

                // WASMロード後に地図を初期化
                initMap();
            } catch (err) {
                console.error("Failed to load Go WebAssembly:", err);
            }
        }

        // 地図状態管理
        let map = {
            lat: 35.676200,
            lng: 139.650300,
            zoom: 8,
            scale: 1.0,
            tileSize: 256,
            isDragging: false,
            lastX: 0,
            lastY: 0,
            pinchInitialDistance: null,
            isPinching: false,
        };

        function updateInfo() {
            const infoDiv = document.getElementById('info');
            infoDiv.innerHTML = `
                <div>緯度: ${map.lat.toFixed(6)}</div>
                <div>経度: ${map.lng.toFixed(6)}</div>
                <div>ズーム: ${map.zoom.toFixed(2)}</div>
            `;
        }

        // 地図描画ロジック
        function updateMap() {
            if (!mapInitialized) {
                return; // 初期化が完了するまで描画しない
            }

            const mapGrid = document.getElementById('mapGrid');
            const [centerX, centerY] = go.exports.getTileCoordinates(map.lat, map.lng, Math.floor(map.zoom));
            const baseZoom = Math.floor(map.zoom);
            
            // 画面サイズに基づき表示タイル数を計算
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const numTilesX = Math.ceil(screenWidth / map.tileSize) + 2;
            const numTilesY = Math.ceil(screenHeight / map.tileSize) + 2;

            const halfWidth = Math.floor(numTilesX / 2);
            const halfHeight = Math.floor(numTilesY / 2);

            mapGrid.innerHTML = '';
            mapGrid.style.width = `${numTilesX * map.tileSize}px`;
            mapGrid.style.height = `${numTilesY * map.tileSize}px`;
            mapGrid.style.transform = `translate(-50%, -50%) scale(${map.scale})`;

            for (let dy = -halfHeight; dy <= halfHeight; dy++) {
                for (let dx = -halfWidth; dx <= halfWidth; dx++) {
                    const tileX = centerX + dx;
                    const tileY = centerY + dy;
                    
                    const screenX = (dx + halfWidth) * map.tileSize;
                    const screenY = (dy + halfHeight) * map.tileSize;

                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.style.width = `${map.tileSize}px`;
                    tile.style.height = `${map.tileSize}px`;
                    tile.style.left = `${screenX}px`;
                    tile.style.top = `${screenY}px`;
                    
                    const img = document.createElement('img');
                    img.src = `https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/${baseZoom}/${tileX}/${tileY}.png`;
                    img.onerror = () => { img.style.display = 'none'; };
                    tile.appendChild(img);
                    
                    mapGrid.appendChild(tile);
                }
            }
            
            updateInfo();
        }

        function initMap() {
            const container = document.getElementById('mapContainer');

            // マウスイベント
            container.addEventListener('mousedown', (e) => {
                map.isDragging = true;
                map.lastX = e.clientX;
                map.lastY = e.clientY;
                container.classList.add('dragging');
            });
            container.addEventListener('mousemove', (e) => {
                if (!map.isDragging) return;
                const deltaX = e.clientX - map.lastX;
                const deltaY = e.clientY - map.lastY;
                const sensitivity = 0.005; 
                map.lng -= deltaX * sensitivity;
                map.lat += deltaY * sensitivity;
                map.lastX = e.clientX;
                map.lastY = e.clientY;
                updateMap();
            });
            container.addEventListener('mouseup', () => {
                map.isDragging = false;
                container.classList.remove('dragging');
            });
            container.addEventListener('mouseleave', () => {
                map.isDragging = false;
                container.classList.remove('dragging');
            });

            // ホイールイベント
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSensitivity = 0.001;
                if (e.deltaY < 0) {
                    map.scale += zoomSensitivity;
                } else {
                    map.scale -= zoomSensitivity;
                }
                
                if (map.scale >= 2.0) {
                    map.zoom++;
                    map.scale = 1.0;
                } else if (map.scale < 1.0) {
                    map.zoom = Math.max(1, map.zoom - 1);
                    map.scale = 1.99;
                }
                
                updateMap();
            });

            // タッチイベント
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    map.isPinching = true;
                    map.pinchInitialDistance = Math.hypot(e.touches[1].clientX - e.touches[0].clientX, e.touches[1].clientY - e.touches[0].clientY);
                } else if (e.touches.length === 1) {
                    map.isDragging = true;
                    map.lastX = e.touches[0].clientX;
                    map.lastY = e.touches[0].clientY;
                }
                e.preventDefault();
            });
            container.addEventListener('touchmove', (e) => {
                if (map.isPinching && e.touches.length === 2) {
                    const currentDistance = Math.hypot(e.touches[1].clientX - e.touches[0].clientX, e.touches[1].clientY - e.touches[0].clientY);
                    const delta = currentDistance - map.pinchInitialDistance;
                    const pinchSensitivity = 0.005;
                    map.scale += delta * pinchSensitivity;
                    
                    if (map.scale >= 2.0) {
                        map.zoom++;
                        map.scale = 1.0;
                    } else if (map.scale < 1.0) {
                        map.zoom = Math.max(1, map.zoom - 1);
                        map.scale = 1.99;
                    }

                    map.pinchInitialDistance = currentDistance;
                } else if (map.isDragging && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - map.lastX;
                    const deltaY = e.touches[0].clientY - map.lastY;
                    const sensitivity = 0.005;
                    map.lng -= deltaX * sensitivity;
                    map.lat += deltaY * sensitivity;
                    map.lastX = e.touches[0].clientX;
                    map.lastY = e.touches[0].clientY;
                }
                updateMap();
                e.preventDefault();
            });
            container.addEventListener('touchend', () => {
                map.isDragging = false;
                map.isPinching = false;
            });
            
            // ウィンドウリサイズイベント
            window.addEventListener('resize', updateMap);
            
            // 初期描画
            mapInitialized = true;
            updateMap();
        }

        // WASMをロード
        loadWasm();
    </script>
</body>
</html>